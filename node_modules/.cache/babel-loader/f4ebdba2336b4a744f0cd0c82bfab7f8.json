{"ast":null,"code":"\"use strict\";\n\n// Copyright (c) 2018-2020 WalletLink.org <https://www.walletlink.org/>\n// Copyright (c) 2018-2020 Coinbase, Inc. <https://www.coinbase.com/>\n// Licensed under the Apache License, version 2.0\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.WalletLinkConnection = void 0;\nconst rxjs_1 = require(\"rxjs\");\nconst operators_1 = require(\"rxjs/operators\");\nconst types_1 = require(\"../types\");\nconst ClientMessage_1 = require(\"./ClientMessage\");\nconst RxWebSocket_1 = require(\"./RxWebSocket\");\nconst ServerMessage_1 = require(\"./ServerMessage\");\nconst HEARTBEAT_INTERVAL = 10000;\nconst REQUEST_TIMEOUT = 60000;\n/**\n * WalletLink Connection\n */\nclass WalletLinkConnection {\n  /**\n   * Constructor\n   * @param sessionId Session ID\n   * @param sessionKey Session Key\n   * @param serverUrl Walletlinkd RPC URL\n   * @param [WebSocketClass] Custom WebSocket implementation\n   */\n  constructor(sessionId, sessionKey, serverUrl) {\n    let WebSocketClass = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : WebSocket;\n    this.sessionId = sessionId;\n    this.sessionKey = sessionKey;\n    this.subscriptions = new rxjs_1.Subscription();\n    this.destroyed = false;\n    this.lastHeartbeatResponse = 0;\n    this.nextReqId = types_1.IntNumber(1);\n    this.connectedSubject = new rxjs_1.BehaviorSubject(false);\n    this.linkedSubject = new rxjs_1.BehaviorSubject(false);\n    this.sessionConfigSubject = new rxjs_1.ReplaySubject(1);\n    const ws = new RxWebSocket_1.RxWebSocket(serverUrl + \"/rpc\", WebSocketClass);\n    this.ws = ws;\n    // attempt to reconnect every 5 seconds when disconnected\n    this.subscriptions.add(ws.connectionState$.pipe(\n    // ignore initial DISCONNECTED state\n    operators_1.skip(1),\n    // if DISCONNECTED and not destroyed\n    operators_1.filter(cs => cs === RxWebSocket_1.ConnectionState.DISCONNECTED && !this.destroyed),\n    // wait 5 seconds\n    operators_1.delay(5000),\n    // check whether it's destroyed again\n    operators_1.filter(_ => !this.destroyed),\n    // reconnect\n    operators_1.flatMap(_ => ws.connect()), operators_1.retry()).subscribe());\n    // perform authentication upon connection\n    this.subscriptions.add(ws.connectionState$.pipe(\n    // ignore initial DISCONNECTED and CONNECTING states\n    operators_1.skip(2), operators_1.switchMap(cs => rxjs_1.iif(() => cs === RxWebSocket_1.ConnectionState.CONNECTED,\n    // if CONNECTED, authenticate, and then check link status\n    this.authenticate().pipe(operators_1.tap(_ => this.sendIsLinked()), operators_1.tap(_ => this.sendGetSessionConfig()), operators_1.map(_ => true)),\n    // if not CONNECTED, emit false immediately\n    rxjs_1.of(false))), operators_1.distinctUntilChanged(), operators_1.catchError(_ => rxjs_1.of(false))).subscribe(connected => this.connectedSubject.next(connected)));\n    // send heartbeat every n seconds while connected\n    this.subscriptions.add(ws.connectionState$.pipe(\n    // ignore initial DISCONNECTED state\n    operators_1.skip(1), operators_1.switchMap(cs => rxjs_1.iif(() => cs === RxWebSocket_1.ConnectionState.CONNECTED,\n    // if CONNECTED, start the heartbeat timer\n    rxjs_1.timer(0, HEARTBEAT_INTERVAL)))).subscribe(i =>\n    // first timer event updates lastHeartbeat timestamp\n    // subsequent calls send heartbeat message\n    i === 0 ? this.updateLastHeartbeat() : this.heartbeat()));\n    // handle server's heartbeat responses\n    this.subscriptions.add(ws.incomingData$.pipe(operators_1.filter(m => m === \"h\")).subscribe(_ => this.updateLastHeartbeat()));\n    // handle link status updates\n    this.subscriptions.add(ws.incomingJSONData$.pipe(operators_1.filter(m => [\"IsLinkedOK\", \"Linked\"].includes(m.type))).subscribe(m => {\n      const msg = m;\n      this.linkedSubject.next(msg.linked || msg.onlineGuests > 0);\n    }));\n    // handle session config updates\n    this.subscriptions.add(ws.incomingJSONData$.pipe(operators_1.filter(m => [\"GetSessionConfigOK\", \"SessionConfigUpdated\"].includes(m.type))).subscribe(m => {\n      const msg = m;\n      this.sessionConfigSubject.next({\n        webhookId: msg.webhookId,\n        webhookUrl: msg.webhookUrl,\n        metadata: msg.metadata\n      });\n    }));\n  }\n  /**\n   * Make a connection to the server\n   */\n  connect() {\n    if (this.destroyed) {\n      throw new Error(\"instance is destroyed\");\n    }\n    this.ws.connect().subscribe();\n  }\n  /**\n   * Terminate connection, and mark as destroyed. To reconnect, create a new\n   * instance of WalletLinkConnection\n   */\n  destroy() {\n    this.subscriptions.unsubscribe();\n    this.ws.disconnect();\n    this.destroyed = true;\n  }\n  /**\n   * Emit true if connected and authenticated, else false\n   * @returns an Observable\n   */\n  get connected$() {\n    return this.connectedSubject.asObservable();\n  }\n  /**\n   * Emit once connected\n   * @returns an Observable\n   */\n  get onceConnected$() {\n    return this.connected$.pipe(operators_1.filter(v => v), operators_1.take(1), operators_1.map(() => void 0));\n  }\n  /**\n   * Emit true if linked (a guest has joined before)\n   * @returns an Observable\n   */\n  get linked$() {\n    return this.linkedSubject.asObservable();\n  }\n  /**\n   * Emit once when linked\n   * @returns an Observable\n   */\n  get onceLinked$() {\n    return this.linked$.pipe(operators_1.filter(v => v), operators_1.take(1), operators_1.map(() => void 0));\n  }\n  /**\n   * Emit current session config if available, and subsequent updates\n   * @returns an Observable for the session config\n   */\n  get sessionConfig$() {\n    return this.sessionConfigSubject.asObservable();\n  }\n  /**\n   * Emit incoming Event messages\n   * @returns an Observable for the messages\n   */\n  get incomingEvent$() {\n    return this.ws.incomingJSONData$.pipe(operators_1.filter(m => {\n      if (m.type !== \"Event\") {\n        return false;\n      }\n      const sme = m;\n      return typeof sme.sessionId === \"string\" && typeof sme.eventId === \"string\" && typeof sme.event === \"string\" && typeof sme.data === \"string\";\n    }), operators_1.map(m => m));\n  }\n  /**\n   * Set session metadata in SessionConfig object\n   * @param key\n   * @param value\n   * @returns an Observable that completes when successful\n   */\n  setSessionMetadata(key, value) {\n    const message = ClientMessage_1.ClientMessageSetSessionConfig({\n      id: types_1.IntNumber(this.nextReqId++),\n      sessionId: this.sessionId,\n      metadata: {\n        [key]: value\n      }\n    });\n    return this.onceConnected$.pipe(operators_1.flatMap(_ => this.makeRequest(message)), operators_1.map(res => {\n      if (ServerMessage_1.isServerMessageFail(res)) {\n        throw new Error(res.error || \"failed to set session metadata\");\n      }\n    }));\n  }\n  /**\n   * Publish an event and emit event ID when successful\n   * @param event event name\n   * @param data event data\n   * @param callWebhook whether the webhook should be invoked\n   * @returns an Observable that emits event ID when successful\n   */\n  publishEvent(event, data) {\n    let callWebhook = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n    const message = ClientMessage_1.ClientMessagePublishEvent({\n      id: types_1.IntNumber(this.nextReqId++),\n      sessionId: this.sessionId,\n      event,\n      data,\n      callWebhook\n    });\n    return this.onceLinked$.pipe(operators_1.flatMap(_ => this.makeRequest(message)), operators_1.map(res => {\n      if (ServerMessage_1.isServerMessageFail(res)) {\n        throw new Error(res.error || \"failed to publish event\");\n      }\n      return res.eventId;\n    }));\n  }\n  sendData(message) {\n    this.ws.sendData(JSON.stringify(message));\n  }\n  updateLastHeartbeat() {\n    this.lastHeartbeatResponse = Date.now();\n  }\n  heartbeat() {\n    if (Date.now() - this.lastHeartbeatResponse > HEARTBEAT_INTERVAL * 2) {\n      this.ws.disconnect();\n      return;\n    }\n    try {\n      this.ws.sendData(\"h\");\n    } catch (_a) {}\n  }\n  makeRequest(message) {\n    let timeout = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : REQUEST_TIMEOUT;\n    const reqId = message.id;\n    try {\n      this.sendData(message);\n    } catch (err) {\n      return rxjs_1.throwError(err);\n    }\n    // await server message with corresponding id\n    return this.ws.incomingJSONData$.pipe(operators_1.timeoutWith(timeout, rxjs_1.throwError(new Error(`request ${reqId} timed out`))), operators_1.filter(m => m.id === reqId), operators_1.take(1));\n  }\n  authenticate() {\n    const msg = ClientMessage_1.ClientMessageHostSession({\n      id: types_1.IntNumber(this.nextReqId++),\n      sessionId: this.sessionId,\n      sessionKey: this.sessionKey\n    });\n    return this.makeRequest(msg).pipe(operators_1.map(res => {\n      if (ServerMessage_1.isServerMessageFail(res)) {\n        throw new Error(res.error || \"failed to authentcate\");\n      }\n    }));\n  }\n  sendIsLinked() {\n    const msg = ClientMessage_1.ClientMessageIsLinked({\n      id: types_1.IntNumber(this.nextReqId++),\n      sessionId: this.sessionId\n    });\n    this.sendData(msg);\n  }\n  sendGetSessionConfig() {\n    const msg = ClientMessage_1.ClientMessageGetSessionConfig({\n      id: types_1.IntNumber(this.nextReqId++),\n      sessionId: this.sessionId\n    });\n    this.sendData(msg);\n  }\n}\nexports.WalletLinkConnection = WalletLinkConnection;","map":{"version":3,"names":["Object","defineProperty","exports","value","WalletLinkConnection","rxjs_1","require","operators_1","types_1","ClientMessage_1","RxWebSocket_1","ServerMessage_1","HEARTBEAT_INTERVAL","REQUEST_TIMEOUT","constructor","sessionId","sessionKey","serverUrl","WebSocketClass","WebSocket","subscriptions","Subscription","destroyed","lastHeartbeatResponse","nextReqId","IntNumber","connectedSubject","BehaviorSubject","linkedSubject","sessionConfigSubject","ReplaySubject","ws","RxWebSocket","add","connectionState$","pipe","skip","filter","cs","ConnectionState","DISCONNECTED","delay","_","flatMap","connect","retry","subscribe","switchMap","iif","CONNECTED","authenticate","tap","sendIsLinked","sendGetSessionConfig","map","of","distinctUntilChanged","catchError","connected","next","timer","i","updateLastHeartbeat","heartbeat","incomingData$","m","incomingJSONData$","includes","type","msg","linked","onlineGuests","webhookId","webhookUrl","metadata","Error","destroy","unsubscribe","disconnect","connected$","asObservable","onceConnected$","v","take","linked$","onceLinked$","sessionConfig$","incomingEvent$","sme","eventId","event","data","setSessionMetadata","key","message","ClientMessageSetSessionConfig","id","makeRequest","res","isServerMessageFail","error","publishEvent","callWebhook","ClientMessagePublishEvent","sendData","JSON","stringify","Date","now","_a","timeout","reqId","err","throwError","timeoutWith","ClientMessageHostSession","ClientMessageIsLinked","ClientMessageGetSessionConfig"],"sources":["/Users/radioactivedevil08/Polygon/starter-kits/node_modules/walletlink/dist/connection/WalletLinkConnection.js"],"sourcesContent":["\"use strict\";\n// Copyright (c) 2018-2020 WalletLink.org <https://www.walletlink.org/>\n// Copyright (c) 2018-2020 Coinbase, Inc. <https://www.coinbase.com/>\n// Licensed under the Apache License, version 2.0\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.WalletLinkConnection = void 0;\nconst rxjs_1 = require(\"rxjs\");\nconst operators_1 = require(\"rxjs/operators\");\nconst types_1 = require(\"../types\");\nconst ClientMessage_1 = require(\"./ClientMessage\");\nconst RxWebSocket_1 = require(\"./RxWebSocket\");\nconst ServerMessage_1 = require(\"./ServerMessage\");\nconst HEARTBEAT_INTERVAL = 10000;\nconst REQUEST_TIMEOUT = 60000;\n/**\n * WalletLink Connection\n */\nclass WalletLinkConnection {\n    /**\n     * Constructor\n     * @param sessionId Session ID\n     * @param sessionKey Session Key\n     * @param serverUrl Walletlinkd RPC URL\n     * @param [WebSocketClass] Custom WebSocket implementation\n     */\n    constructor(sessionId, sessionKey, serverUrl, WebSocketClass = WebSocket) {\n        this.sessionId = sessionId;\n        this.sessionKey = sessionKey;\n        this.subscriptions = new rxjs_1.Subscription();\n        this.destroyed = false;\n        this.lastHeartbeatResponse = 0;\n        this.nextReqId = types_1.IntNumber(1);\n        this.connectedSubject = new rxjs_1.BehaviorSubject(false);\n        this.linkedSubject = new rxjs_1.BehaviorSubject(false);\n        this.sessionConfigSubject = new rxjs_1.ReplaySubject(1);\n        const ws = new RxWebSocket_1.RxWebSocket(serverUrl + \"/rpc\", WebSocketClass);\n        this.ws = ws;\n        // attempt to reconnect every 5 seconds when disconnected\n        this.subscriptions.add(ws.connectionState$\n            .pipe(\n        // ignore initial DISCONNECTED state\n        operators_1.skip(1), \n        // if DISCONNECTED and not destroyed\n        operators_1.filter(cs => cs === RxWebSocket_1.ConnectionState.DISCONNECTED && !this.destroyed), \n        // wait 5 seconds\n        operators_1.delay(5000), \n        // check whether it's destroyed again\n        operators_1.filter(_ => !this.destroyed), \n        // reconnect\n        operators_1.flatMap(_ => ws.connect()), operators_1.retry())\n            .subscribe());\n        // perform authentication upon connection\n        this.subscriptions.add(ws.connectionState$\n            .pipe(\n        // ignore initial DISCONNECTED and CONNECTING states\n        operators_1.skip(2), operators_1.switchMap(cs => rxjs_1.iif(() => cs === RxWebSocket_1.ConnectionState.CONNECTED, \n        // if CONNECTED, authenticate, and then check link status\n        this.authenticate().pipe(operators_1.tap(_ => this.sendIsLinked()), operators_1.tap(_ => this.sendGetSessionConfig()), operators_1.map(_ => true)), \n        // if not CONNECTED, emit false immediately\n        rxjs_1.of(false))), operators_1.distinctUntilChanged(), operators_1.catchError(_ => rxjs_1.of(false)))\n            .subscribe(connected => this.connectedSubject.next(connected)));\n        // send heartbeat every n seconds while connected\n        this.subscriptions.add(ws.connectionState$\n            .pipe(\n        // ignore initial DISCONNECTED state\n        operators_1.skip(1), operators_1.switchMap(cs => rxjs_1.iif(() => cs === RxWebSocket_1.ConnectionState.CONNECTED, \n        // if CONNECTED, start the heartbeat timer\n        rxjs_1.timer(0, HEARTBEAT_INTERVAL))))\n            .subscribe(i => \n        // first timer event updates lastHeartbeat timestamp\n        // subsequent calls send heartbeat message\n        i === 0 ? this.updateLastHeartbeat() : this.heartbeat()));\n        // handle server's heartbeat responses\n        this.subscriptions.add(ws.incomingData$\n            .pipe(operators_1.filter(m => m === \"h\"))\n            .subscribe(_ => this.updateLastHeartbeat()));\n        // handle link status updates\n        this.subscriptions.add(ws.incomingJSONData$\n            .pipe(operators_1.filter(m => [\"IsLinkedOK\", \"Linked\"].includes(m.type)))\n            .subscribe(m => {\n            const msg = m;\n            this.linkedSubject.next(msg.linked || msg.onlineGuests > 0);\n        }));\n        // handle session config updates\n        this.subscriptions.add(ws.incomingJSONData$\n            .pipe(operators_1.filter(m => [\"GetSessionConfigOK\", \"SessionConfigUpdated\"].includes(m.type)))\n            .subscribe(m => {\n            const msg = m;\n            this.sessionConfigSubject.next({\n                webhookId: msg.webhookId,\n                webhookUrl: msg.webhookUrl,\n                metadata: msg.metadata\n            });\n        }));\n    }\n    /**\n     * Make a connection to the server\n     */\n    connect() {\n        if (this.destroyed) {\n            throw new Error(\"instance is destroyed\");\n        }\n        this.ws.connect().subscribe();\n    }\n    /**\n     * Terminate connection, and mark as destroyed. To reconnect, create a new\n     * instance of WalletLinkConnection\n     */\n    destroy() {\n        this.subscriptions.unsubscribe();\n        this.ws.disconnect();\n        this.destroyed = true;\n    }\n    /**\n     * Emit true if connected and authenticated, else false\n     * @returns an Observable\n     */\n    get connected$() {\n        return this.connectedSubject.asObservable();\n    }\n    /**\n     * Emit once connected\n     * @returns an Observable\n     */\n    get onceConnected$() {\n        return this.connected$.pipe(operators_1.filter(v => v), operators_1.take(1), operators_1.map(() => void 0));\n    }\n    /**\n     * Emit true if linked (a guest has joined before)\n     * @returns an Observable\n     */\n    get linked$() {\n        return this.linkedSubject.asObservable();\n    }\n    /**\n     * Emit once when linked\n     * @returns an Observable\n     */\n    get onceLinked$() {\n        return this.linked$.pipe(operators_1.filter(v => v), operators_1.take(1), operators_1.map(() => void 0));\n    }\n    /**\n     * Emit current session config if available, and subsequent updates\n     * @returns an Observable for the session config\n     */\n    get sessionConfig$() {\n        return this.sessionConfigSubject.asObservable();\n    }\n    /**\n     * Emit incoming Event messages\n     * @returns an Observable for the messages\n     */\n    get incomingEvent$() {\n        return this.ws.incomingJSONData$.pipe(operators_1.filter(m => {\n            if (m.type !== \"Event\") {\n                return false;\n            }\n            const sme = m;\n            return (typeof sme.sessionId === \"string\" &&\n                typeof sme.eventId === \"string\" &&\n                typeof sme.event === \"string\" &&\n                typeof sme.data === \"string\");\n        }), operators_1.map(m => m));\n    }\n    /**\n     * Set session metadata in SessionConfig object\n     * @param key\n     * @param value\n     * @returns an Observable that completes when successful\n     */\n    setSessionMetadata(key, value) {\n        const message = ClientMessage_1.ClientMessageSetSessionConfig({\n            id: types_1.IntNumber(this.nextReqId++),\n            sessionId: this.sessionId,\n            metadata: { [key]: value }\n        });\n        return this.onceConnected$.pipe(operators_1.flatMap(_ => this.makeRequest(message)), operators_1.map(res => {\n            if (ServerMessage_1.isServerMessageFail(res)) {\n                throw new Error(res.error || \"failed to set session metadata\");\n            }\n        }));\n    }\n    /**\n     * Publish an event and emit event ID when successful\n     * @param event event name\n     * @param data event data\n     * @param callWebhook whether the webhook should be invoked\n     * @returns an Observable that emits event ID when successful\n     */\n    publishEvent(event, data, callWebhook = false) {\n        const message = ClientMessage_1.ClientMessagePublishEvent({\n            id: types_1.IntNumber(this.nextReqId++),\n            sessionId: this.sessionId,\n            event,\n            data,\n            callWebhook\n        });\n        return this.onceLinked$.pipe(operators_1.flatMap(_ => this.makeRequest(message)), operators_1.map(res => {\n            if (ServerMessage_1.isServerMessageFail(res)) {\n                throw new Error(res.error || \"failed to publish event\");\n            }\n            return res.eventId;\n        }));\n    }\n    sendData(message) {\n        this.ws.sendData(JSON.stringify(message));\n    }\n    updateLastHeartbeat() {\n        this.lastHeartbeatResponse = Date.now();\n    }\n    heartbeat() {\n        if (Date.now() - this.lastHeartbeatResponse > HEARTBEAT_INTERVAL * 2) {\n            this.ws.disconnect();\n            return;\n        }\n        try {\n            this.ws.sendData(\"h\");\n        }\n        catch (_a) { }\n    }\n    makeRequest(message, timeout = REQUEST_TIMEOUT) {\n        const reqId = message.id;\n        try {\n            this.sendData(message);\n        }\n        catch (err) {\n            return rxjs_1.throwError(err);\n        }\n        // await server message with corresponding id\n        return this.ws.incomingJSONData$.pipe(operators_1.timeoutWith(timeout, rxjs_1.throwError(new Error(`request ${reqId} timed out`))), operators_1.filter(m => m.id === reqId), operators_1.take(1));\n    }\n    authenticate() {\n        const msg = ClientMessage_1.ClientMessageHostSession({\n            id: types_1.IntNumber(this.nextReqId++),\n            sessionId: this.sessionId,\n            sessionKey: this.sessionKey\n        });\n        return this.makeRequest(msg).pipe(operators_1.map(res => {\n            if (ServerMessage_1.isServerMessageFail(res)) {\n                throw new Error(res.error || \"failed to authentcate\");\n            }\n        }));\n    }\n    sendIsLinked() {\n        const msg = ClientMessage_1.ClientMessageIsLinked({\n            id: types_1.IntNumber(this.nextReqId++),\n            sessionId: this.sessionId\n        });\n        this.sendData(msg);\n    }\n    sendGetSessionConfig() {\n        const msg = ClientMessage_1.ClientMessageGetSessionConfig({\n            id: types_1.IntNumber(this.nextReqId++),\n            sessionId: this.sessionId\n        });\n        this.sendData(msg);\n    }\n}\nexports.WalletLinkConnection = WalletLinkConnection;\n"],"mappings":"AAAA,YAAY;;AACZ;AACA;AACA;AACAA,MAAM,CAACC,cAAc,CAACC,OAAO,EAAE,YAAY,EAAE;EAAEC,KAAK,EAAE;AAAK,CAAC,CAAC;AAC7DD,OAAO,CAACE,oBAAoB,GAAG,KAAK,CAAC;AACrC,MAAMC,MAAM,GAAGC,OAAO,CAAC,MAAM,CAAC;AAC9B,MAAMC,WAAW,GAAGD,OAAO,CAAC,gBAAgB,CAAC;AAC7C,MAAME,OAAO,GAAGF,OAAO,CAAC,UAAU,CAAC;AACnC,MAAMG,eAAe,GAAGH,OAAO,CAAC,iBAAiB,CAAC;AAClD,MAAMI,aAAa,GAAGJ,OAAO,CAAC,eAAe,CAAC;AAC9C,MAAMK,eAAe,GAAGL,OAAO,CAAC,iBAAiB,CAAC;AAClD,MAAMM,kBAAkB,GAAG,KAAK;AAChC,MAAMC,eAAe,GAAG,KAAK;AAC7B;AACA;AACA;AACA,MAAMT,oBAAoB,CAAC;EACvB;AACJ;AACA;AACA;AACA;AACA;AACA;EACIU,WAAW,CAACC,SAAS,EAAEC,UAAU,EAAEC,SAAS,EAA8B;IAAA,IAA5BC,cAAc,uEAAGC,SAAS;IACpE,IAAI,CAACJ,SAAS,GAAGA,SAAS;IAC1B,IAAI,CAACC,UAAU,GAAGA,UAAU;IAC5B,IAAI,CAACI,aAAa,GAAG,IAAIf,MAAM,CAACgB,YAAY,EAAE;IAC9C,IAAI,CAACC,SAAS,GAAG,KAAK;IACtB,IAAI,CAACC,qBAAqB,GAAG,CAAC;IAC9B,IAAI,CAACC,SAAS,GAAGhB,OAAO,CAACiB,SAAS,CAAC,CAAC,CAAC;IACrC,IAAI,CAACC,gBAAgB,GAAG,IAAIrB,MAAM,CAACsB,eAAe,CAAC,KAAK,CAAC;IACzD,IAAI,CAACC,aAAa,GAAG,IAAIvB,MAAM,CAACsB,eAAe,CAAC,KAAK,CAAC;IACtD,IAAI,CAACE,oBAAoB,GAAG,IAAIxB,MAAM,CAACyB,aAAa,CAAC,CAAC,CAAC;IACvD,MAAMC,EAAE,GAAG,IAAIrB,aAAa,CAACsB,WAAW,CAACf,SAAS,GAAG,MAAM,EAAEC,cAAc,CAAC;IAC5E,IAAI,CAACa,EAAE,GAAGA,EAAE;IACZ;IACA,IAAI,CAACX,aAAa,CAACa,GAAG,CAACF,EAAE,CAACG,gBAAgB,CACrCC,IAAI;IACT;IACA5B,WAAW,CAAC6B,IAAI,CAAC,CAAC,CAAC;IACnB;IACA7B,WAAW,CAAC8B,MAAM,CAACC,EAAE,IAAIA,EAAE,KAAK5B,aAAa,CAAC6B,eAAe,CAACC,YAAY,IAAI,CAAC,IAAI,CAAClB,SAAS,CAAC;IAC9F;IACAf,WAAW,CAACkC,KAAK,CAAC,IAAI,CAAC;IACvB;IACAlC,WAAW,CAAC8B,MAAM,CAACK,CAAC,IAAI,CAAC,IAAI,CAACpB,SAAS,CAAC;IACxC;IACAf,WAAW,CAACoC,OAAO,CAACD,CAAC,IAAIX,EAAE,CAACa,OAAO,EAAE,CAAC,EAAErC,WAAW,CAACsC,KAAK,EAAE,CAAC,CACvDC,SAAS,EAAE,CAAC;IACjB;IACA,IAAI,CAAC1B,aAAa,CAACa,GAAG,CAACF,EAAE,CAACG,gBAAgB,CACrCC,IAAI;IACT;IACA5B,WAAW,CAAC6B,IAAI,CAAC,CAAC,CAAC,EAAE7B,WAAW,CAACwC,SAAS,CAACT,EAAE,IAAIjC,MAAM,CAAC2C,GAAG,CAAC,MAAMV,EAAE,KAAK5B,aAAa,CAAC6B,eAAe,CAACU,SAAS;IAChH;IACA,IAAI,CAACC,YAAY,EAAE,CAACf,IAAI,CAAC5B,WAAW,CAAC4C,GAAG,CAACT,CAAC,IAAI,IAAI,CAACU,YAAY,EAAE,CAAC,EAAE7C,WAAW,CAAC4C,GAAG,CAACT,CAAC,IAAI,IAAI,CAACW,oBAAoB,EAAE,CAAC,EAAE9C,WAAW,CAAC+C,GAAG,CAACZ,CAAC,IAAI,IAAI,CAAC,CAAC;IAClJ;IACArC,MAAM,CAACkD,EAAE,CAAC,KAAK,CAAC,CAAC,CAAC,EAAEhD,WAAW,CAACiD,oBAAoB,EAAE,EAAEjD,WAAW,CAACkD,UAAU,CAACf,CAAC,IAAIrC,MAAM,CAACkD,EAAE,CAAC,KAAK,CAAC,CAAC,CAAC,CACjGT,SAAS,CAACY,SAAS,IAAI,IAAI,CAAChC,gBAAgB,CAACiC,IAAI,CAACD,SAAS,CAAC,CAAC,CAAC;IACnE;IACA,IAAI,CAACtC,aAAa,CAACa,GAAG,CAACF,EAAE,CAACG,gBAAgB,CACrCC,IAAI;IACT;IACA5B,WAAW,CAAC6B,IAAI,CAAC,CAAC,CAAC,EAAE7B,WAAW,CAACwC,SAAS,CAACT,EAAE,IAAIjC,MAAM,CAAC2C,GAAG,CAAC,MAAMV,EAAE,KAAK5B,aAAa,CAAC6B,eAAe,CAACU,SAAS;IAChH;IACA5C,MAAM,CAACuD,KAAK,CAAC,CAAC,EAAEhD,kBAAkB,CAAC,CAAC,CAAC,CAAC,CACjCkC,SAAS,CAACe,CAAC;IAChB;IACA;IACAA,CAAC,KAAK,CAAC,GAAG,IAAI,CAACC,mBAAmB,EAAE,GAAG,IAAI,CAACC,SAAS,EAAE,CAAC,CAAC;IACzD;IACA,IAAI,CAAC3C,aAAa,CAACa,GAAG,CAACF,EAAE,CAACiC,aAAa,CAClC7B,IAAI,CAAC5B,WAAW,CAAC8B,MAAM,CAAC4B,CAAC,IAAIA,CAAC,KAAK,GAAG,CAAC,CAAC,CACxCnB,SAAS,CAACJ,CAAC,IAAI,IAAI,CAACoB,mBAAmB,EAAE,CAAC,CAAC;IAChD;IACA,IAAI,CAAC1C,aAAa,CAACa,GAAG,CAACF,EAAE,CAACmC,iBAAiB,CACtC/B,IAAI,CAAC5B,WAAW,CAAC8B,MAAM,CAAC4B,CAAC,IAAI,CAAC,YAAY,EAAE,QAAQ,CAAC,CAACE,QAAQ,CAACF,CAAC,CAACG,IAAI,CAAC,CAAC,CAAC,CACxEtB,SAAS,CAACmB,CAAC,IAAI;MAChB,MAAMI,GAAG,GAAGJ,CAAC;MACb,IAAI,CAACrC,aAAa,CAAC+B,IAAI,CAACU,GAAG,CAACC,MAAM,IAAID,GAAG,CAACE,YAAY,GAAG,CAAC,CAAC;IAC/D,CAAC,CAAC,CAAC;IACH;IACA,IAAI,CAACnD,aAAa,CAACa,GAAG,CAACF,EAAE,CAACmC,iBAAiB,CACtC/B,IAAI,CAAC5B,WAAW,CAAC8B,MAAM,CAAC4B,CAAC,IAAI,CAAC,oBAAoB,EAAE,sBAAsB,CAAC,CAACE,QAAQ,CAACF,CAAC,CAACG,IAAI,CAAC,CAAC,CAAC,CAC9FtB,SAAS,CAACmB,CAAC,IAAI;MAChB,MAAMI,GAAG,GAAGJ,CAAC;MACb,IAAI,CAACpC,oBAAoB,CAAC8B,IAAI,CAAC;QAC3Ba,SAAS,EAAEH,GAAG,CAACG,SAAS;QACxBC,UAAU,EAAEJ,GAAG,CAACI,UAAU;QAC1BC,QAAQ,EAAEL,GAAG,CAACK;MAClB,CAAC,CAAC;IACN,CAAC,CAAC,CAAC;EACP;EACA;AACJ;AACA;EACI9B,OAAO,GAAG;IACN,IAAI,IAAI,CAACtB,SAAS,EAAE;MAChB,MAAM,IAAIqD,KAAK,CAAC,uBAAuB,CAAC;IAC5C;IACA,IAAI,CAAC5C,EAAE,CAACa,OAAO,EAAE,CAACE,SAAS,EAAE;EACjC;EACA;AACJ;AACA;AACA;EACI8B,OAAO,GAAG;IACN,IAAI,CAACxD,aAAa,CAACyD,WAAW,EAAE;IAChC,IAAI,CAAC9C,EAAE,CAAC+C,UAAU,EAAE;IACpB,IAAI,CAACxD,SAAS,GAAG,IAAI;EACzB;EACA;AACJ;AACA;AACA;EACI,IAAIyD,UAAU,GAAG;IACb,OAAO,IAAI,CAACrD,gBAAgB,CAACsD,YAAY,EAAE;EAC/C;EACA;AACJ;AACA;AACA;EACI,IAAIC,cAAc,GAAG;IACjB,OAAO,IAAI,CAACF,UAAU,CAAC5C,IAAI,CAAC5B,WAAW,CAAC8B,MAAM,CAAC6C,CAAC,IAAIA,CAAC,CAAC,EAAE3E,WAAW,CAAC4E,IAAI,CAAC,CAAC,CAAC,EAAE5E,WAAW,CAAC+C,GAAG,CAAC,MAAM,KAAK,CAAC,CAAC,CAAC;EAC/G;EACA;AACJ;AACA;AACA;EACI,IAAI8B,OAAO,GAAG;IACV,OAAO,IAAI,CAACxD,aAAa,CAACoD,YAAY,EAAE;EAC5C;EACA;AACJ;AACA;AACA;EACI,IAAIK,WAAW,GAAG;IACd,OAAO,IAAI,CAACD,OAAO,CAACjD,IAAI,CAAC5B,WAAW,CAAC8B,MAAM,CAAC6C,CAAC,IAAIA,CAAC,CAAC,EAAE3E,WAAW,CAAC4E,IAAI,CAAC,CAAC,CAAC,EAAE5E,WAAW,CAAC+C,GAAG,CAAC,MAAM,KAAK,CAAC,CAAC,CAAC;EAC5G;EACA;AACJ;AACA;AACA;EACI,IAAIgC,cAAc,GAAG;IACjB,OAAO,IAAI,CAACzD,oBAAoB,CAACmD,YAAY,EAAE;EACnD;EACA;AACJ;AACA;AACA;EACI,IAAIO,cAAc,GAAG;IACjB,OAAO,IAAI,CAACxD,EAAE,CAACmC,iBAAiB,CAAC/B,IAAI,CAAC5B,WAAW,CAAC8B,MAAM,CAAC4B,CAAC,IAAI;MAC1D,IAAIA,CAAC,CAACG,IAAI,KAAK,OAAO,EAAE;QACpB,OAAO,KAAK;MAChB;MACA,MAAMoB,GAAG,GAAGvB,CAAC;MACb,OAAQ,OAAOuB,GAAG,CAACzE,SAAS,KAAK,QAAQ,IACrC,OAAOyE,GAAG,CAACC,OAAO,KAAK,QAAQ,IAC/B,OAAOD,GAAG,CAACE,KAAK,KAAK,QAAQ,IAC7B,OAAOF,GAAG,CAACG,IAAI,KAAK,QAAQ;IACpC,CAAC,CAAC,EAAEpF,WAAW,CAAC+C,GAAG,CAACW,CAAC,IAAIA,CAAC,CAAC,CAAC;EAChC;EACA;AACJ;AACA;AACA;AACA;AACA;EACI2B,kBAAkB,CAACC,GAAG,EAAE1F,KAAK,EAAE;IAC3B,MAAM2F,OAAO,GAAGrF,eAAe,CAACsF,6BAA6B,CAAC;MAC1DC,EAAE,EAAExF,OAAO,CAACiB,SAAS,CAAC,IAAI,CAACD,SAAS,EAAE,CAAC;MACvCT,SAAS,EAAE,IAAI,CAACA,SAAS;MACzB2D,QAAQ,EAAE;QAAE,CAACmB,GAAG,GAAG1F;MAAM;IAC7B,CAAC,CAAC;IACF,OAAO,IAAI,CAAC8E,cAAc,CAAC9C,IAAI,CAAC5B,WAAW,CAACoC,OAAO,CAACD,CAAC,IAAI,IAAI,CAACuD,WAAW,CAACH,OAAO,CAAC,CAAC,EAAEvF,WAAW,CAAC+C,GAAG,CAAC4C,GAAG,IAAI;MACxG,IAAIvF,eAAe,CAACwF,mBAAmB,CAACD,GAAG,CAAC,EAAE;QAC1C,MAAM,IAAIvB,KAAK,CAACuB,GAAG,CAACE,KAAK,IAAI,gCAAgC,CAAC;MAClE;IACJ,CAAC,CAAC,CAAC;EACP;EACA;AACJ;AACA;AACA;AACA;AACA;AACA;EACIC,YAAY,CAACX,KAAK,EAAEC,IAAI,EAAuB;IAAA,IAArBW,WAAW,uEAAG,KAAK;IACzC,MAAMR,OAAO,GAAGrF,eAAe,CAAC8F,yBAAyB,CAAC;MACtDP,EAAE,EAAExF,OAAO,CAACiB,SAAS,CAAC,IAAI,CAACD,SAAS,EAAE,CAAC;MACvCT,SAAS,EAAE,IAAI,CAACA,SAAS;MACzB2E,KAAK;MACLC,IAAI;MACJW;IACJ,CAAC,CAAC;IACF,OAAO,IAAI,CAACjB,WAAW,CAAClD,IAAI,CAAC5B,WAAW,CAACoC,OAAO,CAACD,CAAC,IAAI,IAAI,CAACuD,WAAW,CAACH,OAAO,CAAC,CAAC,EAAEvF,WAAW,CAAC+C,GAAG,CAAC4C,GAAG,IAAI;MACrG,IAAIvF,eAAe,CAACwF,mBAAmB,CAACD,GAAG,CAAC,EAAE;QAC1C,MAAM,IAAIvB,KAAK,CAACuB,GAAG,CAACE,KAAK,IAAI,yBAAyB,CAAC;MAC3D;MACA,OAAOF,GAAG,CAACT,OAAO;IACtB,CAAC,CAAC,CAAC;EACP;EACAe,QAAQ,CAACV,OAAO,EAAE;IACd,IAAI,CAAC/D,EAAE,CAACyE,QAAQ,CAACC,IAAI,CAACC,SAAS,CAACZ,OAAO,CAAC,CAAC;EAC7C;EACAhC,mBAAmB,GAAG;IAClB,IAAI,CAACvC,qBAAqB,GAAGoF,IAAI,CAACC,GAAG,EAAE;EAC3C;EACA7C,SAAS,GAAG;IACR,IAAI4C,IAAI,CAACC,GAAG,EAAE,GAAG,IAAI,CAACrF,qBAAqB,GAAGX,kBAAkB,GAAG,CAAC,EAAE;MAClE,IAAI,CAACmB,EAAE,CAAC+C,UAAU,EAAE;MACpB;IACJ;IACA,IAAI;MACA,IAAI,CAAC/C,EAAE,CAACyE,QAAQ,CAAC,GAAG,CAAC;IACzB,CAAC,CACD,OAAOK,EAAE,EAAE,CAAE;EACjB;EACAZ,WAAW,CAACH,OAAO,EAA6B;IAAA,IAA3BgB,OAAO,uEAAGjG,eAAe;IAC1C,MAAMkG,KAAK,GAAGjB,OAAO,CAACE,EAAE;IACxB,IAAI;MACA,IAAI,CAACQ,QAAQ,CAACV,OAAO,CAAC;IAC1B,CAAC,CACD,OAAOkB,GAAG,EAAE;MACR,OAAO3G,MAAM,CAAC4G,UAAU,CAACD,GAAG,CAAC;IACjC;IACA;IACA,OAAO,IAAI,CAACjF,EAAE,CAACmC,iBAAiB,CAAC/B,IAAI,CAAC5B,WAAW,CAAC2G,WAAW,CAACJ,OAAO,EAAEzG,MAAM,CAAC4G,UAAU,CAAC,IAAItC,KAAK,CAAE,WAAUoC,KAAM,YAAW,CAAC,CAAC,CAAC,EAAExG,WAAW,CAAC8B,MAAM,CAAC4B,CAAC,IAAIA,CAAC,CAAC+B,EAAE,KAAKe,KAAK,CAAC,EAAExG,WAAW,CAAC4E,IAAI,CAAC,CAAC,CAAC,CAAC;EACrM;EACAjC,YAAY,GAAG;IACX,MAAMmB,GAAG,GAAG5D,eAAe,CAAC0G,wBAAwB,CAAC;MACjDnB,EAAE,EAAExF,OAAO,CAACiB,SAAS,CAAC,IAAI,CAACD,SAAS,EAAE,CAAC;MACvCT,SAAS,EAAE,IAAI,CAACA,SAAS;MACzBC,UAAU,EAAE,IAAI,CAACA;IACrB,CAAC,CAAC;IACF,OAAO,IAAI,CAACiF,WAAW,CAAC5B,GAAG,CAAC,CAAClC,IAAI,CAAC5B,WAAW,CAAC+C,GAAG,CAAC4C,GAAG,IAAI;MACrD,IAAIvF,eAAe,CAACwF,mBAAmB,CAACD,GAAG,CAAC,EAAE;QAC1C,MAAM,IAAIvB,KAAK,CAACuB,GAAG,CAACE,KAAK,IAAI,uBAAuB,CAAC;MACzD;IACJ,CAAC,CAAC,CAAC;EACP;EACAhD,YAAY,GAAG;IACX,MAAMiB,GAAG,GAAG5D,eAAe,CAAC2G,qBAAqB,CAAC;MAC9CpB,EAAE,EAAExF,OAAO,CAACiB,SAAS,CAAC,IAAI,CAACD,SAAS,EAAE,CAAC;MACvCT,SAAS,EAAE,IAAI,CAACA;IACpB,CAAC,CAAC;IACF,IAAI,CAACyF,QAAQ,CAACnC,GAAG,CAAC;EACtB;EACAhB,oBAAoB,GAAG;IACnB,MAAMgB,GAAG,GAAG5D,eAAe,CAAC4G,6BAA6B,CAAC;MACtDrB,EAAE,EAAExF,OAAO,CAACiB,SAAS,CAAC,IAAI,CAACD,SAAS,EAAE,CAAC;MACvCT,SAAS,EAAE,IAAI,CAACA;IACpB,CAAC,CAAC;IACF,IAAI,CAACyF,QAAQ,CAACnC,GAAG,CAAC;EACtB;AACJ;AACAnE,OAAO,CAACE,oBAAoB,GAAGA,oBAAoB"},"metadata":{},"sourceType":"script"}