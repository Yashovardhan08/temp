{"ast":null,"code":"'use strict';\n\nvar _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) {\n  return typeof obj;\n} : function (obj) {\n  return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj;\n};\nvar createKeccakHash = require('keccak');\nvar secp256k1 = require('secp256k1');\nvar assert = require('assert');\nvar rlp = require('rlp');\nvar BN = require('bn.js');\nvar createHash = require('create-hash');\nvar Buffer = require('safe-buffer').Buffer;\nObject.assign(exports, require('ethjs-util'));\n\n/**\n * the max integer that this VM can handle (a ```BN```)\n * @var {BN} MAX_INTEGER\n */\nexports.MAX_INTEGER = new BN('ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff', 16);\n\n/**\n * 2^256 (a ```BN```)\n * @var {BN} TWO_POW256\n */\nexports.TWO_POW256 = new BN('10000000000000000000000000000000000000000000000000000000000000000', 16);\n\n/**\n * Keccak-256 hash of null (a ```String```)\n * @var {String} KECCAK256_NULL_S\n */\nexports.KECCAK256_NULL_S = 'c5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470';\nexports.SHA3_NULL_S = exports.KECCAK256_NULL_S;\n\n/**\n * Keccak-256 hash of null (a ```Buffer```)\n * @var {Buffer} KECCAK256_NULL\n */\nexports.KECCAK256_NULL = Buffer.from(exports.KECCAK256_NULL_S, 'hex');\nexports.SHA3_NULL = exports.KECCAK256_NULL;\n\n/**\n * Keccak-256 of an RLP of an empty array (a ```String```)\n * @var {String} KECCAK256_RLP_ARRAY_S\n */\nexports.KECCAK256_RLP_ARRAY_S = '1dcc4de8dec75d7aab85b567b6ccd41ad312451b948a7413f0a142fd40d49347';\nexports.SHA3_RLP_ARRAY_S = exports.KECCAK256_RLP_ARRAY_S;\n\n/**\n * Keccak-256 of an RLP of an empty array (a ```Buffer```)\n * @var {Buffer} KECCAK256_RLP_ARRAY\n */\nexports.KECCAK256_RLP_ARRAY = Buffer.from(exports.KECCAK256_RLP_ARRAY_S, 'hex');\nexports.SHA3_RLP_ARRAY = exports.KECCAK256_RLP_ARRAY;\n\n/**\n * Keccak-256 hash of the RLP of null  (a ```String```)\n * @var {String} KECCAK256_RLP_S\n */\nexports.KECCAK256_RLP_S = '56e81f171bcc55a6ff8345e692c0f86e5b48e01b996cadc001622fb5e363b421';\nexports.SHA3_RLP_S = exports.KECCAK256_RLP_S;\n\n/**\n * Keccak-256 hash of the RLP of null (a ```Buffer```)\n * @var {Buffer} KECCAK256_RLP\n */\nexports.KECCAK256_RLP = Buffer.from(exports.KECCAK256_RLP_S, 'hex');\nexports.SHA3_RLP = exports.KECCAK256_RLP;\n\n/**\n * [`BN`](https://github.com/indutny/bn.js)\n * @var {Function}\n */\nexports.BN = BN;\n\n/**\n * [`rlp`](https://github.com/ethereumjs/rlp)\n * @var {Function}\n */\nexports.rlp = rlp;\n\n/**\n * [`secp256k1`](https://github.com/cryptocoinjs/secp256k1-node/)\n * @var {Object}\n */\nexports.secp256k1 = secp256k1;\n\n/**\n * Returns a buffer filled with 0s\n * @method zeros\n * @param {Number} bytes  the number of bytes the buffer should be\n * @return {Buffer}\n */\nexports.zeros = function (bytes) {\n  return Buffer.allocUnsafe(bytes).fill(0);\n};\n\n/**\n  * Returns a zero address\n  * @method zeroAddress\n  * @return {String}\n  */\nexports.zeroAddress = function () {\n  var addressLength = 20;\n  var zeroAddress = exports.zeros(addressLength);\n  return exports.bufferToHex(zeroAddress);\n};\n\n/**\n * Left Pads an `Array` or `Buffer` with leading zeros till it has `length` bytes.\n * Or it truncates the beginning if it exceeds.\n * @method lsetLength\n * @param {Buffer|Array} msg the value to pad\n * @param {Number} length the number of bytes the output should be\n * @param {Boolean} [right=false] whether to start padding form the left or right\n * @return {Buffer|Array}\n */\nexports.setLengthLeft = exports.setLength = function (msg, length, right) {\n  var buf = exports.zeros(length);\n  msg = exports.toBuffer(msg);\n  if (right) {\n    if (msg.length < length) {\n      msg.copy(buf);\n      return buf;\n    }\n    return msg.slice(0, length);\n  } else {\n    if (msg.length < length) {\n      msg.copy(buf, length - msg.length);\n      return buf;\n    }\n    return msg.slice(-length);\n  }\n};\n\n/**\n * Right Pads an `Array` or `Buffer` with leading zeros till it has `length` bytes.\n * Or it truncates the beginning if it exceeds.\n * @param {Buffer|Array} msg the value to pad\n * @param {Number} length the number of bytes the output should be\n * @return {Buffer|Array}\n */\nexports.setLengthRight = function (msg, length) {\n  return exports.setLength(msg, length, true);\n};\n\n/**\n * Trims leading zeros from a `Buffer` or an `Array`\n * @param {Buffer|Array|String} a\n * @return {Buffer|Array|String}\n */\nexports.unpad = exports.stripZeros = function (a) {\n  a = exports.stripHexPrefix(a);\n  var first = a[0];\n  while (a.length > 0 && first.toString() === '0') {\n    a = a.slice(1);\n    first = a[0];\n  }\n  return a;\n};\n/**\n * Attempts to turn a value into a `Buffer`. As input it supports `Buffer`, `String`, `Number`, null/undefined, `BN` and other objects with a `toArray()` method.\n * @param {*} v the value\n */\nexports.toBuffer = function (v) {\n  if (!Buffer.isBuffer(v)) {\n    if (Array.isArray(v)) {\n      v = Buffer.from(v);\n    } else if (typeof v === 'string') {\n      if (exports.isHexString(v)) {\n        v = Buffer.from(exports.padToEven(exports.stripHexPrefix(v)), 'hex');\n      } else {\n        v = Buffer.from(v);\n      }\n    } else if (typeof v === 'number') {\n      v = exports.intToBuffer(v);\n    } else if (v === null || v === undefined) {\n      v = Buffer.allocUnsafe(0);\n    } else if (BN.isBN(v)) {\n      v = v.toArrayLike(Buffer);\n    } else if (v.toArray) {\n      // converts a BN to a Buffer\n      v = Buffer.from(v.toArray());\n    } else {\n      throw new Error('invalid type');\n    }\n  }\n  return v;\n};\n\n/**\n * Converts a `Buffer` to a `Number`\n * @param {Buffer} buf\n * @return {Number}\n * @throws If the input number exceeds 53 bits.\n */\nexports.bufferToInt = function (buf) {\n  return new BN(exports.toBuffer(buf)).toNumber();\n};\n\n/**\n * Converts a `Buffer` into a hex `String`\n * @param {Buffer} buf\n * @return {String}\n */\nexports.bufferToHex = function (buf) {\n  buf = exports.toBuffer(buf);\n  return '0x' + buf.toString('hex');\n};\n\n/**\n * Interprets a `Buffer` as a signed integer and returns a `BN`. Assumes 256-bit numbers.\n * @param {Buffer} num\n * @return {BN}\n */\nexports.fromSigned = function (num) {\n  return new BN(num).fromTwos(256);\n};\n\n/**\n * Converts a `BN` to an unsigned integer and returns it as a `Buffer`. Assumes 256-bit numbers.\n * @param {BN} num\n * @return {Buffer}\n */\nexports.toUnsigned = function (num) {\n  return Buffer.from(num.toTwos(256).toArray());\n};\n\n/**\n * Creates Keccak hash of the input\n * @param {Buffer|Array|String|Number} a the input data\n * @param {Number} [bits=256] the Keccak width\n * @return {Buffer}\n */\nexports.keccak = function (a, bits) {\n  a = exports.toBuffer(a);\n  if (!bits) bits = 256;\n  return createKeccakHash('keccak' + bits).update(a).digest();\n};\n\n/**\n * Creates Keccak-256 hash of the input, alias for keccak(a, 256)\n * @param {Buffer|Array|String|Number} a the input data\n * @return {Buffer}\n */\nexports.keccak256 = function (a) {\n  return exports.keccak(a);\n};\n\n/**\n * Creates SHA-3 (Keccak) hash of the input [OBSOLETE]\n * @param {Buffer|Array|String|Number} a the input data\n * @param {Number} [bits=256] the SHA-3 width\n * @return {Buffer}\n */\nexports.sha3 = exports.keccak;\n\n/**\n * Creates SHA256 hash of the input\n * @param {Buffer|Array|String|Number} a the input data\n * @return {Buffer}\n */\nexports.sha256 = function (a) {\n  a = exports.toBuffer(a);\n  return createHash('sha256').update(a).digest();\n};\n\n/**\n * Creates RIPEMD160 hash of the input\n * @param {Buffer|Array|String|Number} a the input data\n * @param {Boolean} padded whether it should be padded to 256 bits or not\n * @return {Buffer}\n */\nexports.ripemd160 = function (a, padded) {\n  a = exports.toBuffer(a);\n  var hash = createHash('rmd160').update(a).digest();\n  if (padded === true) {\n    return exports.setLength(hash, 32);\n  } else {\n    return hash;\n  }\n};\n\n/**\n * Creates SHA-3 hash of the RLP encoded version of the input\n * @param {Buffer|Array|String|Number} a the input data\n * @return {Buffer}\n */\nexports.rlphash = function (a) {\n  return exports.keccak(rlp.encode(a));\n};\n\n/**\n * Checks if the private key satisfies the rules of the curve secp256k1.\n * @param {Buffer} privateKey\n * @return {Boolean}\n */\nexports.isValidPrivate = function (privateKey) {\n  return secp256k1.privateKeyVerify(privateKey);\n};\n\n/**\n * Checks if the public key satisfies the rules of the curve secp256k1\n * and the requirements of Ethereum.\n * @param {Buffer} publicKey The two points of an uncompressed key, unless sanitize is enabled\n * @param {Boolean} [sanitize=false] Accept public keys in other formats\n * @return {Boolean}\n */\nexports.isValidPublic = function (publicKey, sanitize) {\n  if (publicKey.length === 64) {\n    // Convert to SEC1 for secp256k1\n    return secp256k1.publicKeyVerify(Buffer.concat([Buffer.from([4]), publicKey]));\n  }\n  if (!sanitize) {\n    return false;\n  }\n  return secp256k1.publicKeyVerify(publicKey);\n};\n\n/**\n * Returns the ethereum address of a given public key.\n * Accepts \"Ethereum public keys\" and SEC1 encoded keys.\n * @param {Buffer} pubKey The two points of an uncompressed key, unless sanitize is enabled\n * @param {Boolean} [sanitize=false] Accept public keys in other formats\n * @return {Buffer}\n */\nexports.pubToAddress = exports.publicToAddress = function (pubKey, sanitize) {\n  pubKey = exports.toBuffer(pubKey);\n  if (sanitize && pubKey.length !== 64) {\n    pubKey = secp256k1.publicKeyConvert(pubKey, false).slice(1);\n  }\n  assert(pubKey.length === 64);\n  // Only take the lower 160bits of the hash\n  return exports.keccak(pubKey).slice(-20);\n};\n\n/**\n * Returns the ethereum public key of a given private key\n * @param {Buffer} privateKey A private key must be 256 bits wide\n * @return {Buffer}\n */\nvar privateToPublic = exports.privateToPublic = function (privateKey) {\n  privateKey = exports.toBuffer(privateKey);\n  // skip the type flag and use the X, Y points\n  return secp256k1.publicKeyCreate(privateKey, false).slice(1);\n};\n\n/**\n * Converts a public key to the Ethereum format.\n * @param {Buffer} publicKey\n * @return {Buffer}\n */\nexports.importPublic = function (publicKey) {\n  publicKey = exports.toBuffer(publicKey);\n  if (publicKey.length !== 64) {\n    publicKey = secp256k1.publicKeyConvert(publicKey, false).slice(1);\n  }\n  return publicKey;\n};\n\n/**\n * ECDSA sign\n * @param {Buffer} msgHash\n * @param {Buffer} privateKey\n * @return {Object}\n */\nexports.ecsign = function (msgHash, privateKey) {\n  var sig = secp256k1.sign(msgHash, privateKey);\n  var ret = {};\n  ret.r = sig.signature.slice(0, 32);\n  ret.s = sig.signature.slice(32, 64);\n  ret.v = sig.recovery + 27;\n  return ret;\n};\n\n/**\n * Returns the keccak-256 hash of `message`, prefixed with the header used by the `eth_sign` RPC call.\n * The output of this function can be fed into `ecsign` to produce the same signature as the `eth_sign`\n * call for a given `message`, or fed to `ecrecover` along with a signature to recover the public key\n * used to produce the signature.\n * @param message\n * @returns {Buffer} hash\n */\nexports.hashPersonalMessage = function (message) {\n  var prefix = exports.toBuffer('\\x19Ethereum Signed Message:\\n' + message.length.toString());\n  return exports.keccak(Buffer.concat([prefix, message]));\n};\n\n/**\n * ECDSA public key recovery from signature\n * @param {Buffer} msgHash\n * @param {Number} v\n * @param {Buffer} r\n * @param {Buffer} s\n * @return {Buffer} publicKey\n */\nexports.ecrecover = function (msgHash, v, r, s) {\n  var signature = Buffer.concat([exports.setLength(r, 32), exports.setLength(s, 32)], 64);\n  var recovery = v - 27;\n  if (recovery !== 0 && recovery !== 1) {\n    throw new Error('Invalid signature v value');\n  }\n  var senderPubKey = secp256k1.recover(msgHash, signature, recovery);\n  return secp256k1.publicKeyConvert(senderPubKey, false).slice(1);\n};\n\n/**\n * Convert signature parameters into the format of `eth_sign` RPC method\n * @param {Number} v\n * @param {Buffer} r\n * @param {Buffer} s\n * @return {String} sig\n */\nexports.toRpcSig = function (v, r, s) {\n  // NOTE: with potential introduction of chainId this might need to be updated\n  if (v !== 27 && v !== 28) {\n    throw new Error('Invalid recovery id');\n  }\n\n  // geth (and the RPC eth_sign method) uses the 65 byte format used by Bitcoin\n  // FIXME: this might change in the future - https://github.com/ethereum/go-ethereum/issues/2053\n  return exports.bufferToHex(Buffer.concat([exports.setLengthLeft(r, 32), exports.setLengthLeft(s, 32), exports.toBuffer(v - 27)]));\n};\n\n/**\n * Convert signature format of the `eth_sign` RPC method to signature parameters\n * NOTE: all because of a bug in geth: https://github.com/ethereum/go-ethereum/issues/2053\n * @param {String} sig\n * @return {Object}\n */\nexports.fromRpcSig = function (sig) {\n  sig = exports.toBuffer(sig);\n\n  // NOTE: with potential introduction of chainId this might need to be updated\n  if (sig.length !== 65) {\n    throw new Error('Invalid signature length');\n  }\n  var v = sig[64];\n  // support both versions of `eth_sign` responses\n  if (v < 27) {\n    v += 27;\n  }\n  return {\n    v: v,\n    r: sig.slice(0, 32),\n    s: sig.slice(32, 64)\n  };\n};\n\n/**\n * Returns the ethereum address of a given private key\n * @param {Buffer} privateKey A private key must be 256 bits wide\n * @return {Buffer}\n */\nexports.privateToAddress = function (privateKey) {\n  return exports.publicToAddress(privateToPublic(privateKey));\n};\n\n/**\n * Checks if the address is a valid. Accepts checksummed addresses too\n * @param {String} address\n * @return {Boolean}\n */\nexports.isValidAddress = function (address) {\n  return /^0x[0-9a-fA-F]{40}$/.test(address);\n};\n\n/**\n  * Checks if a given address is a zero address\n  * @method isZeroAddress\n  * @param {String} address\n  * @return {Boolean}\n  */\nexports.isZeroAddress = function (address) {\n  var zeroAddress = exports.zeroAddress();\n  return zeroAddress === exports.addHexPrefix(address);\n};\n\n/**\n * Returns a checksummed address\n * @param {String} address\n * @return {String}\n */\nexports.toChecksumAddress = function (address) {\n  address = exports.stripHexPrefix(address).toLowerCase();\n  var hash = exports.keccak(address).toString('hex');\n  var ret = '0x';\n  for (var i = 0; i < address.length; i++) {\n    if (parseInt(hash[i], 16) >= 8) {\n      ret += address[i].toUpperCase();\n    } else {\n      ret += address[i];\n    }\n  }\n  return ret;\n};\n\n/**\n * Checks if the address is a valid checksummed address\n * @param {Buffer} address\n * @return {Boolean}\n */\nexports.isValidChecksumAddress = function (address) {\n  return exports.isValidAddress(address) && exports.toChecksumAddress(address) === address;\n};\n\n/**\n * Generates an address of a newly created contract\n * @param {Buffer} from the address which is creating this new address\n * @param {Buffer} nonce the nonce of the from account\n * @return {Buffer}\n */\nexports.generateAddress = function (from, nonce) {\n  from = exports.toBuffer(from);\n  nonce = new BN(nonce);\n  if (nonce.isZero()) {\n    // in RLP we want to encode null in the case of zero nonce\n    // read the RLP documentation for an answer if you dare\n    nonce = null;\n  } else {\n    nonce = Buffer.from(nonce.toArray());\n  }\n\n  // Only take the lower 160bits of the hash\n  return exports.rlphash([from, nonce]).slice(-20);\n};\n\n/**\n * Returns true if the supplied address belongs to a precompiled account (Byzantium)\n * @param {Buffer|String} address\n * @return {Boolean}\n */\nexports.isPrecompiled = function (address) {\n  var a = exports.unpad(address);\n  return a.length === 1 && a[0] >= 1 && a[0] <= 8;\n};\n\n/**\n * Adds \"0x\" to a given `String` if it does not already start with \"0x\"\n * @param {String} str\n * @return {String}\n */\nexports.addHexPrefix = function (str) {\n  if (typeof str !== 'string') {\n    return str;\n  }\n  return exports.isHexPrefixed(str) ? str : '0x' + str;\n};\n\n/**\n * Validate ECDSA signature\n * @method isValidSignature\n * @param {Buffer} v\n * @param {Buffer} r\n * @param {Buffer} s\n * @param {Boolean} [homestead=true]\n * @return {Boolean}\n */\n\nexports.isValidSignature = function (v, r, s, homestead) {\n  var SECP256K1_N_DIV_2 = new BN('7fffffffffffffffffffffffffffffff5d576e7357a4501ddfe92f46681b20a0', 16);\n  var SECP256K1_N = new BN('fffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364141', 16);\n  if (r.length !== 32 || s.length !== 32) {\n    return false;\n  }\n  if (v !== 27 && v !== 28) {\n    return false;\n  }\n  r = new BN(r);\n  s = new BN(s);\n  if (r.isZero() || r.gt(SECP256K1_N) || s.isZero() || s.gt(SECP256K1_N)) {\n    return false;\n  }\n  if (homestead === false && new BN(s).cmp(SECP256K1_N_DIV_2) === 1) {\n    return false;\n  }\n  return true;\n};\n\n/**\n * Converts a `Buffer` or `Array` to JSON\n * @param {Buffer|Array} ba\n * @return {Array|String|null}\n */\nexports.baToJSON = function (ba) {\n  if (Buffer.isBuffer(ba)) {\n    return '0x' + ba.toString('hex');\n  } else if (ba instanceof Array) {\n    var array = [];\n    for (var i = 0; i < ba.length; i++) {\n      array.push(exports.baToJSON(ba[i]));\n    }\n    return array;\n  }\n};\n\n/**\n * Defines properties on a `Object`. It make the assumption that underlying data is binary.\n * @param {Object} self the `Object` to define properties on\n * @param {Array} fields an array fields to define. Fields can contain:\n * * `name` - the name of the properties\n * * `length` - the number of bytes the field can have\n * * `allowLess` - if the field can be less than the length\n * * `allowEmpty`\n * @param {*} data data to be validated against the definitions\n */\nexports.defineProperties = function (self, fields, data) {\n  self.raw = [];\n  self._fields = [];\n\n  // attach the `toJSON`\n  self.toJSON = function (label) {\n    if (label) {\n      var obj = {};\n      self._fields.forEach(function (field) {\n        obj[field] = '0x' + self[field].toString('hex');\n      });\n      return obj;\n    }\n    return exports.baToJSON(this.raw);\n  };\n  self.serialize = function serialize() {\n    return rlp.encode(self.raw);\n  };\n  fields.forEach(function (field, i) {\n    self._fields.push(field.name);\n    function getter() {\n      return self.raw[i];\n    }\n    function setter(v) {\n      v = exports.toBuffer(v);\n      if (v.toString('hex') === '00' && !field.allowZero) {\n        v = Buffer.allocUnsafe(0);\n      }\n      if (field.allowLess && field.length) {\n        v = exports.stripZeros(v);\n        assert(field.length >= v.length, 'The field ' + field.name + ' must not have more ' + field.length + ' bytes');\n      } else if (!(field.allowZero && v.length === 0) && field.length) {\n        assert(field.length === v.length, 'The field ' + field.name + ' must have byte length of ' + field.length);\n      }\n      self.raw[i] = v;\n    }\n    Object.defineProperty(self, field.name, {\n      enumerable: true,\n      configurable: true,\n      get: getter,\n      set: setter\n    });\n    if (field.default) {\n      self[field.name] = field.default;\n    }\n\n    // attach alias\n    if (field.alias) {\n      Object.defineProperty(self, field.alias, {\n        enumerable: false,\n        configurable: true,\n        set: setter,\n        get: getter\n      });\n    }\n  });\n\n  // if the constuctor is passed data\n  if (data) {\n    if (typeof data === 'string') {\n      data = Buffer.from(exports.stripHexPrefix(data), 'hex');\n    }\n    if (Buffer.isBuffer(data)) {\n      data = rlp.decode(data);\n    }\n    if (Array.isArray(data)) {\n      if (data.length > self._fields.length) {\n        throw new Error('wrong number of fields in data');\n      }\n\n      // make sure all the items are buffers\n      data.forEach(function (d, i) {\n        self[self._fields[i]] = exports.toBuffer(d);\n      });\n    } else if ((typeof data === 'undefined' ? 'undefined' : _typeof(data)) === 'object') {\n      var keys = Object.keys(data);\n      fields.forEach(function (field) {\n        if (keys.indexOf(field.name) !== -1) self[field.name] = data[field.name];\n        if (keys.indexOf(field.alias) !== -1) self[field.alias] = data[field.alias];\n      });\n    } else {\n      throw new Error('invalid data');\n    }\n  }\n};","map":{"version":3,"names":["_typeof","Symbol","iterator","obj","constructor","prototype","createKeccakHash","require","secp256k1","assert","rlp","BN","createHash","Buffer","Object","assign","exports","MAX_INTEGER","TWO_POW256","KECCAK256_NULL_S","SHA3_NULL_S","KECCAK256_NULL","from","SHA3_NULL","KECCAK256_RLP_ARRAY_S","SHA3_RLP_ARRAY_S","KECCAK256_RLP_ARRAY","SHA3_RLP_ARRAY","KECCAK256_RLP_S","SHA3_RLP_S","KECCAK256_RLP","SHA3_RLP","zeros","bytes","allocUnsafe","fill","zeroAddress","addressLength","bufferToHex","setLengthLeft","setLength","msg","length","right","buf","toBuffer","copy","slice","setLengthRight","unpad","stripZeros","a","stripHexPrefix","first","toString","v","isBuffer","Array","isArray","isHexString","padToEven","intToBuffer","undefined","isBN","toArrayLike","toArray","Error","bufferToInt","toNumber","fromSigned","num","fromTwos","toUnsigned","toTwos","keccak","bits","update","digest","keccak256","sha3","sha256","ripemd160","padded","hash","rlphash","encode","isValidPrivate","privateKey","privateKeyVerify","isValidPublic","publicKey","sanitize","publicKeyVerify","concat","pubToAddress","publicToAddress","pubKey","publicKeyConvert","privateToPublic","publicKeyCreate","importPublic","ecsign","msgHash","sig","sign","ret","r","signature","s","recovery","hashPersonalMessage","message","prefix","ecrecover","senderPubKey","recover","toRpcSig","fromRpcSig","privateToAddress","isValidAddress","address","test","isZeroAddress","addHexPrefix","toChecksumAddress","toLowerCase","i","parseInt","toUpperCase","isValidChecksumAddress","generateAddress","nonce","isZero","isPrecompiled","str","isHexPrefixed","isValidSignature","homestead","SECP256K1_N_DIV_2","SECP256K1_N","gt","cmp","baToJSON","ba","array","push","defineProperties","self","fields","data","raw","_fields","toJSON","label","forEach","field","serialize","name","getter","setter","allowZero","allowLess","defineProperty","enumerable","configurable","get","set","default","alias","decode","d","keys","indexOf"],"sources":["/Users/radioactivedevil08/Polygon/starter-kits/node_modules/ethereumjs-util/dist/index.js"],"sourcesContent":["'use strict';\n\nvar _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; };\n\nvar createKeccakHash = require('keccak');\nvar secp256k1 = require('secp256k1');\nvar assert = require('assert');\nvar rlp = require('rlp');\nvar BN = require('bn.js');\nvar createHash = require('create-hash');\nvar Buffer = require('safe-buffer').Buffer;\nObject.assign(exports, require('ethjs-util'));\n\n/**\n * the max integer that this VM can handle (a ```BN```)\n * @var {BN} MAX_INTEGER\n */\nexports.MAX_INTEGER = new BN('ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff', 16);\n\n/**\n * 2^256 (a ```BN```)\n * @var {BN} TWO_POW256\n */\nexports.TWO_POW256 = new BN('10000000000000000000000000000000000000000000000000000000000000000', 16);\n\n/**\n * Keccak-256 hash of null (a ```String```)\n * @var {String} KECCAK256_NULL_S\n */\nexports.KECCAK256_NULL_S = 'c5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470';\nexports.SHA3_NULL_S = exports.KECCAK256_NULL_S;\n\n/**\n * Keccak-256 hash of null (a ```Buffer```)\n * @var {Buffer} KECCAK256_NULL\n */\nexports.KECCAK256_NULL = Buffer.from(exports.KECCAK256_NULL_S, 'hex');\nexports.SHA3_NULL = exports.KECCAK256_NULL;\n\n/**\n * Keccak-256 of an RLP of an empty array (a ```String```)\n * @var {String} KECCAK256_RLP_ARRAY_S\n */\nexports.KECCAK256_RLP_ARRAY_S = '1dcc4de8dec75d7aab85b567b6ccd41ad312451b948a7413f0a142fd40d49347';\nexports.SHA3_RLP_ARRAY_S = exports.KECCAK256_RLP_ARRAY_S;\n\n/**\n * Keccak-256 of an RLP of an empty array (a ```Buffer```)\n * @var {Buffer} KECCAK256_RLP_ARRAY\n */\nexports.KECCAK256_RLP_ARRAY = Buffer.from(exports.KECCAK256_RLP_ARRAY_S, 'hex');\nexports.SHA3_RLP_ARRAY = exports.KECCAK256_RLP_ARRAY;\n\n/**\n * Keccak-256 hash of the RLP of null  (a ```String```)\n * @var {String} KECCAK256_RLP_S\n */\nexports.KECCAK256_RLP_S = '56e81f171bcc55a6ff8345e692c0f86e5b48e01b996cadc001622fb5e363b421';\nexports.SHA3_RLP_S = exports.KECCAK256_RLP_S;\n\n/**\n * Keccak-256 hash of the RLP of null (a ```Buffer```)\n * @var {Buffer} KECCAK256_RLP\n */\nexports.KECCAK256_RLP = Buffer.from(exports.KECCAK256_RLP_S, 'hex');\nexports.SHA3_RLP = exports.KECCAK256_RLP;\n\n/**\n * [`BN`](https://github.com/indutny/bn.js)\n * @var {Function}\n */\nexports.BN = BN;\n\n/**\n * [`rlp`](https://github.com/ethereumjs/rlp)\n * @var {Function}\n */\nexports.rlp = rlp;\n\n/**\n * [`secp256k1`](https://github.com/cryptocoinjs/secp256k1-node/)\n * @var {Object}\n */\nexports.secp256k1 = secp256k1;\n\n/**\n * Returns a buffer filled with 0s\n * @method zeros\n * @param {Number} bytes  the number of bytes the buffer should be\n * @return {Buffer}\n */\nexports.zeros = function (bytes) {\n  return Buffer.allocUnsafe(bytes).fill(0);\n};\n\n/**\n  * Returns a zero address\n  * @method zeroAddress\n  * @return {String}\n  */\nexports.zeroAddress = function () {\n  var addressLength = 20;\n  var zeroAddress = exports.zeros(addressLength);\n  return exports.bufferToHex(zeroAddress);\n};\n\n/**\n * Left Pads an `Array` or `Buffer` with leading zeros till it has `length` bytes.\n * Or it truncates the beginning if it exceeds.\n * @method lsetLength\n * @param {Buffer|Array} msg the value to pad\n * @param {Number} length the number of bytes the output should be\n * @param {Boolean} [right=false] whether to start padding form the left or right\n * @return {Buffer|Array}\n */\nexports.setLengthLeft = exports.setLength = function (msg, length, right) {\n  var buf = exports.zeros(length);\n  msg = exports.toBuffer(msg);\n  if (right) {\n    if (msg.length < length) {\n      msg.copy(buf);\n      return buf;\n    }\n    return msg.slice(0, length);\n  } else {\n    if (msg.length < length) {\n      msg.copy(buf, length - msg.length);\n      return buf;\n    }\n    return msg.slice(-length);\n  }\n};\n\n/**\n * Right Pads an `Array` or `Buffer` with leading zeros till it has `length` bytes.\n * Or it truncates the beginning if it exceeds.\n * @param {Buffer|Array} msg the value to pad\n * @param {Number} length the number of bytes the output should be\n * @return {Buffer|Array}\n */\nexports.setLengthRight = function (msg, length) {\n  return exports.setLength(msg, length, true);\n};\n\n/**\n * Trims leading zeros from a `Buffer` or an `Array`\n * @param {Buffer|Array|String} a\n * @return {Buffer|Array|String}\n */\nexports.unpad = exports.stripZeros = function (a) {\n  a = exports.stripHexPrefix(a);\n  var first = a[0];\n  while (a.length > 0 && first.toString() === '0') {\n    a = a.slice(1);\n    first = a[0];\n  }\n  return a;\n};\n/**\n * Attempts to turn a value into a `Buffer`. As input it supports `Buffer`, `String`, `Number`, null/undefined, `BN` and other objects with a `toArray()` method.\n * @param {*} v the value\n */\nexports.toBuffer = function (v) {\n  if (!Buffer.isBuffer(v)) {\n    if (Array.isArray(v)) {\n      v = Buffer.from(v);\n    } else if (typeof v === 'string') {\n      if (exports.isHexString(v)) {\n        v = Buffer.from(exports.padToEven(exports.stripHexPrefix(v)), 'hex');\n      } else {\n        v = Buffer.from(v);\n      }\n    } else if (typeof v === 'number') {\n      v = exports.intToBuffer(v);\n    } else if (v === null || v === undefined) {\n      v = Buffer.allocUnsafe(0);\n    } else if (BN.isBN(v)) {\n      v = v.toArrayLike(Buffer);\n    } else if (v.toArray) {\n      // converts a BN to a Buffer\n      v = Buffer.from(v.toArray());\n    } else {\n      throw new Error('invalid type');\n    }\n  }\n  return v;\n};\n\n/**\n * Converts a `Buffer` to a `Number`\n * @param {Buffer} buf\n * @return {Number}\n * @throws If the input number exceeds 53 bits.\n */\nexports.bufferToInt = function (buf) {\n  return new BN(exports.toBuffer(buf)).toNumber();\n};\n\n/**\n * Converts a `Buffer` into a hex `String`\n * @param {Buffer} buf\n * @return {String}\n */\nexports.bufferToHex = function (buf) {\n  buf = exports.toBuffer(buf);\n  return '0x' + buf.toString('hex');\n};\n\n/**\n * Interprets a `Buffer` as a signed integer and returns a `BN`. Assumes 256-bit numbers.\n * @param {Buffer} num\n * @return {BN}\n */\nexports.fromSigned = function (num) {\n  return new BN(num).fromTwos(256);\n};\n\n/**\n * Converts a `BN` to an unsigned integer and returns it as a `Buffer`. Assumes 256-bit numbers.\n * @param {BN} num\n * @return {Buffer}\n */\nexports.toUnsigned = function (num) {\n  return Buffer.from(num.toTwos(256).toArray());\n};\n\n/**\n * Creates Keccak hash of the input\n * @param {Buffer|Array|String|Number} a the input data\n * @param {Number} [bits=256] the Keccak width\n * @return {Buffer}\n */\nexports.keccak = function (a, bits) {\n  a = exports.toBuffer(a);\n  if (!bits) bits = 256;\n\n  return createKeccakHash('keccak' + bits).update(a).digest();\n};\n\n/**\n * Creates Keccak-256 hash of the input, alias for keccak(a, 256)\n * @param {Buffer|Array|String|Number} a the input data\n * @return {Buffer}\n */\nexports.keccak256 = function (a) {\n  return exports.keccak(a);\n};\n\n/**\n * Creates SHA-3 (Keccak) hash of the input [OBSOLETE]\n * @param {Buffer|Array|String|Number} a the input data\n * @param {Number} [bits=256] the SHA-3 width\n * @return {Buffer}\n */\nexports.sha3 = exports.keccak;\n\n/**\n * Creates SHA256 hash of the input\n * @param {Buffer|Array|String|Number} a the input data\n * @return {Buffer}\n */\nexports.sha256 = function (a) {\n  a = exports.toBuffer(a);\n  return createHash('sha256').update(a).digest();\n};\n\n/**\n * Creates RIPEMD160 hash of the input\n * @param {Buffer|Array|String|Number} a the input data\n * @param {Boolean} padded whether it should be padded to 256 bits or not\n * @return {Buffer}\n */\nexports.ripemd160 = function (a, padded) {\n  a = exports.toBuffer(a);\n  var hash = createHash('rmd160').update(a).digest();\n  if (padded === true) {\n    return exports.setLength(hash, 32);\n  } else {\n    return hash;\n  }\n};\n\n/**\n * Creates SHA-3 hash of the RLP encoded version of the input\n * @param {Buffer|Array|String|Number} a the input data\n * @return {Buffer}\n */\nexports.rlphash = function (a) {\n  return exports.keccak(rlp.encode(a));\n};\n\n/**\n * Checks if the private key satisfies the rules of the curve secp256k1.\n * @param {Buffer} privateKey\n * @return {Boolean}\n */\nexports.isValidPrivate = function (privateKey) {\n  return secp256k1.privateKeyVerify(privateKey);\n};\n\n/**\n * Checks if the public key satisfies the rules of the curve secp256k1\n * and the requirements of Ethereum.\n * @param {Buffer} publicKey The two points of an uncompressed key, unless sanitize is enabled\n * @param {Boolean} [sanitize=false] Accept public keys in other formats\n * @return {Boolean}\n */\nexports.isValidPublic = function (publicKey, sanitize) {\n  if (publicKey.length === 64) {\n    // Convert to SEC1 for secp256k1\n    return secp256k1.publicKeyVerify(Buffer.concat([Buffer.from([4]), publicKey]));\n  }\n\n  if (!sanitize) {\n    return false;\n  }\n\n  return secp256k1.publicKeyVerify(publicKey);\n};\n\n/**\n * Returns the ethereum address of a given public key.\n * Accepts \"Ethereum public keys\" and SEC1 encoded keys.\n * @param {Buffer} pubKey The two points of an uncompressed key, unless sanitize is enabled\n * @param {Boolean} [sanitize=false] Accept public keys in other formats\n * @return {Buffer}\n */\nexports.pubToAddress = exports.publicToAddress = function (pubKey, sanitize) {\n  pubKey = exports.toBuffer(pubKey);\n  if (sanitize && pubKey.length !== 64) {\n    pubKey = secp256k1.publicKeyConvert(pubKey, false).slice(1);\n  }\n  assert(pubKey.length === 64);\n  // Only take the lower 160bits of the hash\n  return exports.keccak(pubKey).slice(-20);\n};\n\n/**\n * Returns the ethereum public key of a given private key\n * @param {Buffer} privateKey A private key must be 256 bits wide\n * @return {Buffer}\n */\nvar privateToPublic = exports.privateToPublic = function (privateKey) {\n  privateKey = exports.toBuffer(privateKey);\n  // skip the type flag and use the X, Y points\n  return secp256k1.publicKeyCreate(privateKey, false).slice(1);\n};\n\n/**\n * Converts a public key to the Ethereum format.\n * @param {Buffer} publicKey\n * @return {Buffer}\n */\nexports.importPublic = function (publicKey) {\n  publicKey = exports.toBuffer(publicKey);\n  if (publicKey.length !== 64) {\n    publicKey = secp256k1.publicKeyConvert(publicKey, false).slice(1);\n  }\n  return publicKey;\n};\n\n/**\n * ECDSA sign\n * @param {Buffer} msgHash\n * @param {Buffer} privateKey\n * @return {Object}\n */\nexports.ecsign = function (msgHash, privateKey) {\n  var sig = secp256k1.sign(msgHash, privateKey);\n\n  var ret = {};\n  ret.r = sig.signature.slice(0, 32);\n  ret.s = sig.signature.slice(32, 64);\n  ret.v = sig.recovery + 27;\n  return ret;\n};\n\n/**\n * Returns the keccak-256 hash of `message`, prefixed with the header used by the `eth_sign` RPC call.\n * The output of this function can be fed into `ecsign` to produce the same signature as the `eth_sign`\n * call for a given `message`, or fed to `ecrecover` along with a signature to recover the public key\n * used to produce the signature.\n * @param message\n * @returns {Buffer} hash\n */\nexports.hashPersonalMessage = function (message) {\n  var prefix = exports.toBuffer('\\x19Ethereum Signed Message:\\n' + message.length.toString());\n  return exports.keccak(Buffer.concat([prefix, message]));\n};\n\n/**\n * ECDSA public key recovery from signature\n * @param {Buffer} msgHash\n * @param {Number} v\n * @param {Buffer} r\n * @param {Buffer} s\n * @return {Buffer} publicKey\n */\nexports.ecrecover = function (msgHash, v, r, s) {\n  var signature = Buffer.concat([exports.setLength(r, 32), exports.setLength(s, 32)], 64);\n  var recovery = v - 27;\n  if (recovery !== 0 && recovery !== 1) {\n    throw new Error('Invalid signature v value');\n  }\n  var senderPubKey = secp256k1.recover(msgHash, signature, recovery);\n  return secp256k1.publicKeyConvert(senderPubKey, false).slice(1);\n};\n\n/**\n * Convert signature parameters into the format of `eth_sign` RPC method\n * @param {Number} v\n * @param {Buffer} r\n * @param {Buffer} s\n * @return {String} sig\n */\nexports.toRpcSig = function (v, r, s) {\n  // NOTE: with potential introduction of chainId this might need to be updated\n  if (v !== 27 && v !== 28) {\n    throw new Error('Invalid recovery id');\n  }\n\n  // geth (and the RPC eth_sign method) uses the 65 byte format used by Bitcoin\n  // FIXME: this might change in the future - https://github.com/ethereum/go-ethereum/issues/2053\n  return exports.bufferToHex(Buffer.concat([exports.setLengthLeft(r, 32), exports.setLengthLeft(s, 32), exports.toBuffer(v - 27)]));\n};\n\n/**\n * Convert signature format of the `eth_sign` RPC method to signature parameters\n * NOTE: all because of a bug in geth: https://github.com/ethereum/go-ethereum/issues/2053\n * @param {String} sig\n * @return {Object}\n */\nexports.fromRpcSig = function (sig) {\n  sig = exports.toBuffer(sig);\n\n  // NOTE: with potential introduction of chainId this might need to be updated\n  if (sig.length !== 65) {\n    throw new Error('Invalid signature length');\n  }\n\n  var v = sig[64];\n  // support both versions of `eth_sign` responses\n  if (v < 27) {\n    v += 27;\n  }\n\n  return {\n    v: v,\n    r: sig.slice(0, 32),\n    s: sig.slice(32, 64)\n  };\n};\n\n/**\n * Returns the ethereum address of a given private key\n * @param {Buffer} privateKey A private key must be 256 bits wide\n * @return {Buffer}\n */\nexports.privateToAddress = function (privateKey) {\n  return exports.publicToAddress(privateToPublic(privateKey));\n};\n\n/**\n * Checks if the address is a valid. Accepts checksummed addresses too\n * @param {String} address\n * @return {Boolean}\n */\nexports.isValidAddress = function (address) {\n  return (/^0x[0-9a-fA-F]{40}$/.test(address)\n  );\n};\n\n/**\n  * Checks if a given address is a zero address\n  * @method isZeroAddress\n  * @param {String} address\n  * @return {Boolean}\n  */\nexports.isZeroAddress = function (address) {\n  var zeroAddress = exports.zeroAddress();\n  return zeroAddress === exports.addHexPrefix(address);\n};\n\n/**\n * Returns a checksummed address\n * @param {String} address\n * @return {String}\n */\nexports.toChecksumAddress = function (address) {\n  address = exports.stripHexPrefix(address).toLowerCase();\n  var hash = exports.keccak(address).toString('hex');\n  var ret = '0x';\n\n  for (var i = 0; i < address.length; i++) {\n    if (parseInt(hash[i], 16) >= 8) {\n      ret += address[i].toUpperCase();\n    } else {\n      ret += address[i];\n    }\n  }\n\n  return ret;\n};\n\n/**\n * Checks if the address is a valid checksummed address\n * @param {Buffer} address\n * @return {Boolean}\n */\nexports.isValidChecksumAddress = function (address) {\n  return exports.isValidAddress(address) && exports.toChecksumAddress(address) === address;\n};\n\n/**\n * Generates an address of a newly created contract\n * @param {Buffer} from the address which is creating this new address\n * @param {Buffer} nonce the nonce of the from account\n * @return {Buffer}\n */\nexports.generateAddress = function (from, nonce) {\n  from = exports.toBuffer(from);\n  nonce = new BN(nonce);\n\n  if (nonce.isZero()) {\n    // in RLP we want to encode null in the case of zero nonce\n    // read the RLP documentation for an answer if you dare\n    nonce = null;\n  } else {\n    nonce = Buffer.from(nonce.toArray());\n  }\n\n  // Only take the lower 160bits of the hash\n  return exports.rlphash([from, nonce]).slice(-20);\n};\n\n/**\n * Returns true if the supplied address belongs to a precompiled account (Byzantium)\n * @param {Buffer|String} address\n * @return {Boolean}\n */\nexports.isPrecompiled = function (address) {\n  var a = exports.unpad(address);\n  return a.length === 1 && a[0] >= 1 && a[0] <= 8;\n};\n\n/**\n * Adds \"0x\" to a given `String` if it does not already start with \"0x\"\n * @param {String} str\n * @return {String}\n */\nexports.addHexPrefix = function (str) {\n  if (typeof str !== 'string') {\n    return str;\n  }\n\n  return exports.isHexPrefixed(str) ? str : '0x' + str;\n};\n\n/**\n * Validate ECDSA signature\n * @method isValidSignature\n * @param {Buffer} v\n * @param {Buffer} r\n * @param {Buffer} s\n * @param {Boolean} [homestead=true]\n * @return {Boolean}\n */\n\nexports.isValidSignature = function (v, r, s, homestead) {\n  var SECP256K1_N_DIV_2 = new BN('7fffffffffffffffffffffffffffffff5d576e7357a4501ddfe92f46681b20a0', 16);\n  var SECP256K1_N = new BN('fffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364141', 16);\n\n  if (r.length !== 32 || s.length !== 32) {\n    return false;\n  }\n\n  if (v !== 27 && v !== 28) {\n    return false;\n  }\n\n  r = new BN(r);\n  s = new BN(s);\n\n  if (r.isZero() || r.gt(SECP256K1_N) || s.isZero() || s.gt(SECP256K1_N)) {\n    return false;\n  }\n\n  if (homestead === false && new BN(s).cmp(SECP256K1_N_DIV_2) === 1) {\n    return false;\n  }\n\n  return true;\n};\n\n/**\n * Converts a `Buffer` or `Array` to JSON\n * @param {Buffer|Array} ba\n * @return {Array|String|null}\n */\nexports.baToJSON = function (ba) {\n  if (Buffer.isBuffer(ba)) {\n    return '0x' + ba.toString('hex');\n  } else if (ba instanceof Array) {\n    var array = [];\n    for (var i = 0; i < ba.length; i++) {\n      array.push(exports.baToJSON(ba[i]));\n    }\n    return array;\n  }\n};\n\n/**\n * Defines properties on a `Object`. It make the assumption that underlying data is binary.\n * @param {Object} self the `Object` to define properties on\n * @param {Array} fields an array fields to define. Fields can contain:\n * * `name` - the name of the properties\n * * `length` - the number of bytes the field can have\n * * `allowLess` - if the field can be less than the length\n * * `allowEmpty`\n * @param {*} data data to be validated against the definitions\n */\nexports.defineProperties = function (self, fields, data) {\n  self.raw = [];\n  self._fields = [];\n\n  // attach the `toJSON`\n  self.toJSON = function (label) {\n    if (label) {\n      var obj = {};\n      self._fields.forEach(function (field) {\n        obj[field] = '0x' + self[field].toString('hex');\n      });\n      return obj;\n    }\n    return exports.baToJSON(this.raw);\n  };\n\n  self.serialize = function serialize() {\n    return rlp.encode(self.raw);\n  };\n\n  fields.forEach(function (field, i) {\n    self._fields.push(field.name);\n    function getter() {\n      return self.raw[i];\n    }\n    function setter(v) {\n      v = exports.toBuffer(v);\n\n      if (v.toString('hex') === '00' && !field.allowZero) {\n        v = Buffer.allocUnsafe(0);\n      }\n\n      if (field.allowLess && field.length) {\n        v = exports.stripZeros(v);\n        assert(field.length >= v.length, 'The field ' + field.name + ' must not have more ' + field.length + ' bytes');\n      } else if (!(field.allowZero && v.length === 0) && field.length) {\n        assert(field.length === v.length, 'The field ' + field.name + ' must have byte length of ' + field.length);\n      }\n\n      self.raw[i] = v;\n    }\n\n    Object.defineProperty(self, field.name, {\n      enumerable: true,\n      configurable: true,\n      get: getter,\n      set: setter\n    });\n\n    if (field.default) {\n      self[field.name] = field.default;\n    }\n\n    // attach alias\n    if (field.alias) {\n      Object.defineProperty(self, field.alias, {\n        enumerable: false,\n        configurable: true,\n        set: setter,\n        get: getter\n      });\n    }\n  });\n\n  // if the constuctor is passed data\n  if (data) {\n    if (typeof data === 'string') {\n      data = Buffer.from(exports.stripHexPrefix(data), 'hex');\n    }\n\n    if (Buffer.isBuffer(data)) {\n      data = rlp.decode(data);\n    }\n\n    if (Array.isArray(data)) {\n      if (data.length > self._fields.length) {\n        throw new Error('wrong number of fields in data');\n      }\n\n      // make sure all the items are buffers\n      data.forEach(function (d, i) {\n        self[self._fields[i]] = exports.toBuffer(d);\n      });\n    } else if ((typeof data === 'undefined' ? 'undefined' : _typeof(data)) === 'object') {\n      var keys = Object.keys(data);\n      fields.forEach(function (field) {\n        if (keys.indexOf(field.name) !== -1) self[field.name] = data[field.name];\n        if (keys.indexOf(field.alias) !== -1) self[field.alias] = data[field.alias];\n      });\n    } else {\n      throw new Error('invalid data');\n    }\n  }\n};"],"mappings":"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"},"metadata":{},"sourceType":"script"}